# java 内存泄漏

### java内存泄漏的原因
java中的对象从使用上分为两种类型，被引用和不被引用的。垃圾回收只会回收不被引用的对象。被引用的对象，即使不再使用了也不会被回收。
因此程序中大量出现被引用的无用对象时，就是内存泄漏。

### 内存泄漏的典型场景

#### 对象被静态成员引用

当大对象被静态成员引用时，会造成内存泄漏。

#### String的intern方法

在大字符串上调用String.intern()方法，如果大字符串不存在会把大放入常量池中，
而常量池是不会被gc的。因此如果大字符串调用调用intern()方法后，会产生大量无法gc的内存，导致内存泄漏。
  
#### 读取流后没有关闭

开发中经常忘记关闭流，这样会导致内存泄漏。因为每个流在操作系统层面都对应了打开的文件句柄，流没有关闭，会导致操作系统的文件句柄一直处于打开状态，而jvm会消耗内存来跟踪操作系统打开的文件句柄。 示例

#### 将没有实现hashCode()和equals()方法的对象加入到HashSet中

这是一个简单却很常见的场景。正常情况下Set会过滤重复的对象，但是如果没有hashCode() 和 equals()实现，重复对象会不断被加入到Set中，并且再也没有机会去移除。

### java内存泄漏的原因

### 查找内存泄漏的方法

#### 记录gc日志
通过在jvm参数中指定-verbose:gc，可以记录每次gc的情况，用于内存分析。

#### 进行profiling
通过Visual VM 或 jdk自带的Java Mission Control，进行内存分析。

### 总结

代码层面的检查可以帮助发现部分内存泄漏的问题，但是生产环境中的内存泄漏往往不容易提前发现，因为很多问题是在大并发场景下才会出现。因此还需要通过压力测试工具进行压力测试，提前发现潜在的内存泄漏问题。