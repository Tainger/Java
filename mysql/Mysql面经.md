# mysql面经

## 基础

### 1. 数据库三大范式

- 第一范式: 强调列是原子性，即数据库表的每一列都是不可分割的原子数据项。
- 第二范式: 要求实体的属性完全依赖关键字。所谓完全依赖是指不能存在仅依赖主关键字一部分属性。
- 第三范式: 任何非主属性不依赖其它主属性。

### 2. MYSQL支持呢些
Mysql支持多种存储引擎，比如InnoDB， MyISAM， Memory， Archive等等。直接选择使用InnoDB引擎都是最合适的，InnoDB也是Mysql默认的存储引擎
- InnoDB 支持事务， MyISAM 不支持。
- InnoDB 支持外键, MyISM不支持
- InnoDB 是聚簇索引，数据文件和索引是绑在一起的，必须要有主键，通过主键索引效率很高。MyISM是非聚簇索引，索引保存的是数据的指针，主键索引和辅助索引是独立的。
- InnoDB 不支持全文索引，而MyISM支持全文索引。查询效率上MyISM效率要高
- InnoDB 不保存表的具体行数，MyISAM用一个变量保存了整个表的行数。
- InnoDB 支持行级锁和表级锁，默认为行级锁。 MyISAM采用是表级锁。
- InnoDB 支持RedoLog,支持crash-safe能力。


### 3. SQL 约束有哪几种？
- NOT NULL: 用于控制字段的内容一定不能为空（NULL）。
- UNIQUE: 控件字段内容不能重复，一个表允许有多个 Unique 约束。
- PRIMARY KEY: 也是用于控件字段内容不能重复，但它在一个表只允许出现一个。
- FOREIGN KEY: 用于预防破坏表之间连接的动作，也能防止非法数据插入外键列，因为它必须是它指向的那个表中的值之一。
- CHECK: 用于控制字段的值范围。

### 9. SQL 约束有哪几种？
1. 客户端通过TCP连接发送连接请求到Mysql连接器，连接器会对该请求进行权限验证及连接资源分配。
2. 查缓存。（当判断缓存是否命中时，MySQL 不会进行解析查询语句，而是直接使用 SQL 语句和客户端发送过来的其他原始信息。所以，任何字符上的不同，例如空格、注解等都会导致缓存的不命中。）
3. 语法分析（SQL 语法是否写错了）。 如何把语句给到预处理器，检查数据表和数据列是否存在，解析别名看是否存在歧义。
4. 优化。是否使用索引，生成执行计划。
5. 交给执行器，将数据保存到结果集中，同时会逐步将数据缓存到查询缓存中，最终将结果集返回给客户端。

![preview](https://we-take-bucket.oss-cn-beijing.aliyuncs.com/imgv2-87eceeb9a8d6b50d41b841a92d909c1b_r.jpg)

更新语句执行会复杂一点。需要检查表是否有排它锁，写 binlog，刷盘，是否执行 commit。



## 事务

### 1.**什么是数据库事务？**

事务是一个不可分割的数据库操作序列，也是数据库并发控制的基本单位，其执行的结果必须使数据库从一种一致性状态变到另一种一致性状态。事务是逻辑上的一组操作，要么都执行，要么都不执行。

事务最经典也经常被拿出来说例子就是转账了。

假如小明要给小红转账1000元，这个转账会涉及到两个关键操作就是：将小明的余额减少1000元，将小红的余额增加1000元。万一在这两个操作之间突然出现错误比如银行系统崩溃，导致小明余额减少而小红的余额没有增加，这样就不对了。事务就是保证这两个关键操作要么都成功，要么都要失败。



### **2. 介绍一下事务具有的四个特征**

事务就是一组原子性的操作，这些操作要么全部发生，要么全部不发生。事务把数据库从一种一致性状态转换成为另一种一致性状态。

- 原子性。事务是数据库的逻辑工作单位，事务中包含的操作要么都做，要么都不做。
- 一致性。事务执行的结果和数据库的状态符合一致我们称为一致性。因此当数据库只包含成功事务提交的结果时，就说数据库处于一致性状态。如果数据库系统运行中发生故障，有些事务尚未执行就被迫中断，这些未完成事务的数据对数据库所做的修改有一部分已写入物理数据库，这时数据库就处于一种不正确的状态。
- 隔离性。一个事务的执行不能干扰其他事务的执行。即一个事务内部的操作及使用的数据对其他并发事务是隔离的，并发执行的事务之间不能相互干扰。
- 持续性。也称永久性。指一个事务一旦提交，对数据库中的数据改变就应该是永久性的。接下来的操作或者故障不应该对其执行结果有任何影响。

### 3. 说一下MySQL 的四种隔离级别

- Read Uncommitted(读取未提交内容) 

在该隔离级别，所有事务都可以看其他未提交事务的执行结果。本隔离级别很少用于实际应用，因为它的性能也不其他级别好多少。读取未提交的数据，也被称为脏读。(Dirty Read)

- Read Committed (读取已提交的内容)

这是大多数数据库的默认级别，但是mysql不是的。它满足了隔离的简单定义: 一个事务只能看到已经提交的事务的改变。这种隔离级别也称为不可重复读。一个事务在它没有执行完成，在另一个事务执行完成前读到的结果，和另一个事务执行完成后读到的结果可能是不一样的。

- Repeatable Read(可重复读)

这是Mysql默认的隔离级别，它确保同一个事务的执行语句在并发读取数据时，会看到同样的数据行。不过理论上，这会导致另一个棘手的问题: 幻读。

- Serializable（可串行化）

通过强制事务排序，使之不可能相互冲突，从而解决幻读问题。简言之，它是在每个读的数据行上加上共享锁。在这个级别，可能导致大量的超时现象和锁竞争。

![image-20210902213642511](https://we-take-bucket.oss-cn-beijing.aliyuncs.com/imgimage-20210902213642511.png)



MySQL默认采用的REPEATABLE_READ隔离级别，Oracle提供读已提交隔离级别。



事务的隔离机制的实现基于**锁机制**和**并发调度**。其中并发调度使用的是**MVVC**（多版本并发控制），通过保存修改的旧版本信息来支持并发一致性读和回滚特性。



因为隔离级别越低，事务请求的锁就越少，所以大部分数据库的隔离级别都是读已提交；但是Mysql数据库是可重复读并不会有任何损失。



InnoDB存储引擎在分布式事务的情况下一般会用到Serializable（可串性化）隔离级别。



### 4. 什么是脏读？幻读？不可重复读？

1. 脏读：事务A读取了事务B更新的数据，然后B回滚操作，那么A读取到的数据是脏数据。
2. 不可重复读：事务A多次读取同一数据，事务B在事务A多次读取的过程中，对数据锁了更新并提交，导致事务A多次读取同一数据时，结果不一致。
3. 幻读：系统管理员 A 将数据库中所有学生的成绩从具体分数改为 ABCDE 等级，但是系统管理员 B 就在这个时候插入了一条具体分数的记录，当系统管理员 A 改结束后发现还有一条记录没有改过来，就好像发生了幻觉一样，这就叫幻读。

不可重复读侧重于修改，幻读侧重于新增或删除（多了或少量行），脏读是一个事务回滚影响另外一个事务。

### 5. 事务实现的原理

事务是基于重做日志文件(redo log)和回滚日志(undo log)实现的。

每提交一个事务必须先将该事务的所有日志写入到重做日志文件进行持久化，数据库就可以通过重做日志来保证事务的原子性和持久性。

每当有修改事务时，还会产生 undo log，如果需要回滚，则根据 undo log 的反向语句进行逻辑操作，比如 insert 一条记录就 delete 一条记录。undo log 主要实现数据库的一致性。

### 6. MySQL事务日志介绍下？

innodb 事务日志包括redo log 和 undo log。

undo log 指事务开始之前，在操作任何数据之前，首先将需操作的数据备份到一个地方。redo log指事务中操作任何数据，将最新的备份到一个地方。

事务日志到目的: 实例或者介质失败，事务日志文件就能派上用场。

redo log 不是随着



