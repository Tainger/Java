## 索引的优化面试题分析

一张titles表我们对emp_no, title, from_date做组合索引判断下面几个sql语句使用索引的情况:

- select * from titles where emp_no = '1001' And title = 'Senior Engineer' And from_date = ''1986-06-26";
- select * from titles where title = 'Senior Engineer';
- select * from titles where emp_no > '1001';
- select * from titles where emp_no > '1001' and title = 'Senior Engineer';
- select * from titles where emp_po > '1001' order by title;

## 索引到底是什么

- **索引**是帮助Mysql高效获取数据的**排好序**的**数据结构**

- 索引存储在**文件**里

- 索引的结构有哪些

  - 二叉树
  - 红黑树 
  - HASH
  - **BTREE**
    - 度（Degree) - 节点的数据存储的个数
    - 叶节点具有相同的深度
    - 叶节点的指针为空
    - 节点中的数据key从左到右递增排列
  - B+ Tree
    - 非叶子节点不存储data，只存储key，可以增加度。
    - 叶子节点存储数据（**非叶子节点索引会存在冗余**）
    - **顺序访问指针，提高区间的访问的性能。**（范围查询）
    - B+Tree索引的性能分析
      - 一般使用io次数评价索引结构的优劣
      - 预读：磁盘一般会顺序向后读区一定长度的数据（页的整数倍）放入内存
      - 局部性原理：当一个数据被使用到时，其附近的数据也通常会马上被使用
      - B+Tree节点的大小设为等于一个页，每次新建的节点直接申请一个页的存储空间，这样就保证一个节点物理上也存储在一个页里，就实现了一个节点载入只需要一次I/O
      - B+Tree的度d一般会超过100，因此h非常小（一般为3到5之间）

   **Q:既然度的节点可以无限增大，可以降低树的深度，那么我们为什么不把节点无限增大呢？**
  在操作系统中内存和磁盘的是以页的单位进行读取的，假设我们一次io只能取一次数据，一页大小为4k，如果我们一个节点度很多，这样一个节点就很大，读这个节点我们可能要进行多次I/O。这样一个节点反而会导致多的io次数，然后每次查询一个节点就会带来多次i/o。如果和一个节点4k比较的话，它只需要io一次，而另一个需要io多次。

  所以索引也是存储在磁盘中的。

  ### mysql中每一条数据存储

  每次向mysql中插入每一行数据不可能紧密挨着，它们可能离散的分布在磁盘的各个部分

  ### 磁盘存储原理

  - 磁盘存取原理
    - 寻道时间（速度慢，费时）
    - 旋转时间（速度较快）
    - 读取时间

  这样每次读区一行数据就要消耗 t1 =**寻道时间+旋转时间+ 读取时间** 时间。

  ![WeChatca7ddff94a78f721dec7c74b0e97bebe](/Users/rocky/study/github/Java-technology-stack/image/WeChatca7ddff94a78f721dec7c74b0e97bebe.png)

  如果没有索引的话，读col2 为22 这条数据进行全表扫描5次，5 * t1的时间。相反如果我们通过索引就可能只需要1次，和34比较一次然后和22比较一次找到22的值以及对应的指针，然后查询一次磁盘就可以了。

  ## MyISAM索引实现（非聚集）

  MyISAM索引实现（非聚集）。

  **MyISAM索引文件和数据文件是分离的**。

  注： 存储引擎是在表级别。



MyISAM存储的是一个行的地址

存储引擎是MyISAM引擎的底层有三个文件，一个是MyISAM_lock.firm ，myisam.myd, myisam.index



## Innodb的索引

- 数据文件本身就是索引文件。
- 表数据文件本身就是按B+Tree组织的一个索引结构文件。
- 聚簇索引叶节点包含了完整的数据记录。
- 为什么InnoDB表必须有主键，并且推荐使用整型的自增主键？

因为他要根据一个主键去建立索引。如果你没有设置主键，mysql会自动选一个可以作为主键的值。自增型整型主键如果要插入新的数据，他就会基本落在b+树的最后的一个节点中，根据b+树的算法离散的分布在其他的节点，造成索引节点分裂造成额外的io操作。

**用uuid和自增主键有什么区别？**

uuid比大小会按照assic码值依次比较，而且uuid比较长，在建立非聚簇索引的时候浪费存储空间。

自增主键是插在最后一页的结构，然后uuid生成的字符串是随机的，它们会随机生成插入随机一个叶子节点。会造成其他叶子节点的分裂。还有可能插入一个没有读入磁盘的一个节点，这样又会造成一次io操作。

- 为什么非主键索引结构叶子节点存储的是主键值？（**一致性**和**节省存储空间**）

  如果某一行的数据删除了，聚簇索引更新了，非聚簇索引就不用更新了，若果非要不存在主键存地址，并没有类似唯一的东西去去b+树中匹配删除。

  若果更新表的值，只需要更新主键索引了。其他的索引索引就不需要更新了。

**聚簇索引每个节点的地址存储的是每一行的整条数据。**

这就是为什么innodb引擎表只有两个文件。

一个是test_innodb_lock.firm 表的形式，另一个是表的索引和数据。所以聚簇索引放的是节点和数据。

![1605355890117](/Users/rocky/study/github/Java-technology-stack/image/1605355890117.jpg)

在innodb数据文件就是索引文件的情况下，索引被依次读入内存，根据b+树算法一次读取下一节点，一直读到匹配的叶子节点，讲道理最后一行的叶子节点读取了所有内容。

## 联合索引

### 最左前缀索引原理





## Exlain详解与索引最佳实践

```

```



## 问题总结：

